#!/usr/bin/env ruby

require 'rubygems'
require 'trollop'
require 'mysql'

ARGV.push("--help") if ARGV.empty?
opts = Trollop::options do
  banner File.basename($0)
  opt :input, "tax num file", :type=>:string, :required=>true
  opt :usedTaxa, "use usedTaxa.tab rather than phylodb mysql for info"
  opt :nodes, "use NCBI nodes.dmp", :type=>:string
  opt :names, "use NCBI names.dmp (with nodes.dmp)", :type=>:string
  opt :verbose, "verbose messaging"
end

if (!opts.usedTaxa && !opts.nodes)
  db = Mysql.new("mysql-lan-pro", "access", "access", "phylodb")
elsif (opts.usedTaxa)
  tax = Hash.new
  File.new(opts.usedTaxa).each do |line|
    current, name, parent, rank = line.chomp.split("\t")
    tax[current.to_i] = [name, parent.to_i, rank]
  end
  db = tax
elsif (opts.nodes)
  tax = Hash.new
  names = Hash.new
  File.new(opts.names).each do |line|
    num, name = line.chomp.split("\t|\t")
    names[num.to_i] = name
  end
  File.new(opts.nodes).each do |line|
    current, parent, rank = line.chomp.split("\t|\t")
    tax[current.to_i] = [names[current.to_i], parent.to_i, rank]
  end
  db = tax
end

def recurseTaxonomy(db, current, verbose)
  if (db.class == Hash)
    name, parent, rank = db[current]
  else
    name, parent, rank = db.query("SELECT name, parent_id, rank FROM taxonomy WHERE taxon_id=#{current}").fetch_row
  end
  if (name.nil? || parent.to_i == 1)
    []
  else
    name = name + " (" + current.to_s + ")" if verbose
    recurseTaxonomy(db, parent, verbose).to_a + [name] 
  end
end


if (opts.file)
  ids = []
  File.new(opts.input).each do |line|
    ids.push(line.chomp.to_i)
  end
else
  ids = opts.input
end

File.new(opts.input).each do |line|
  name, taxid = line.chomp.split(" ")
  taxid = name if !taxid
  print name + "\t " + recurseTaxonomy(db, taxid.to_i, opts.verbose).join("; ") + "\n"
end