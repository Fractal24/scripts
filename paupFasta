#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'Phylogeny'
require 'ostruct'
require 'fpdf'

$VERBOSE = nil

opt = OpenStruct.new
opt.algorithm = "nj"
opt.estimate = false
opt.noboot = false
opt.outgroup = nil
opt.unrooted = false
opt.trim = false
opt.numboot = 100
opt.project = nil

def cleanup(dir)
  system("rm -rf #{dir}")	
end

ARGV.options {|opts|
  opts.banner << " fasta [fasta...]"
  opts.on("-b", "--noboot", 
          "don't bootstrap (default #{opt.noboot})") {opt.noboot = true}
  opts.on("-n ", "--numboot ", Integer, 
        "number of bootstrap reps  (default #{opt.numboot})") {|n| opt.numboot = n}
  opts.on("-e", "--estimate", 
         "estimate branch lengths (default #{opt.estimate})") {opt.estimate = true}    
  opts.on("-m ", "--method ", String, 
          "method (default #{opt.algorithm} -  nj, pars, ml valid)") {|alg| opt.algorithm = alg}
  opts.on("-o ", "--outgroup ", String, "outgroup") {|g| opt.outgroup = g}
  opts.on("-u", "--unrooted", "leave tree unrooted") {opt.unrooted = true}
  opts.on("-t", "--trim", "trim alignment (default #{opt.trim})") {opt.trim = true}
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size < 1)
    STDERR.puts opts
    exit(1)
  end
}

if (opt.algorithm != "pars" && opt.algorithm != "nj" && opt.algorithm != "ml")
  STDERR.printf("only pars, ml, and nj are supported\n")
  exit(1)
end

ARGV.each {|fasta|
  name = File.basename(fasta).split(".").first
  tmpdir = ENV["HOME"] + "/.tmp"
  Dir.mkdir(tmpdir) if !File.exists?(tmpdir)
  tmpdir += "/" + name + "_" + Time.now.to_f.to_s
  Dir.mkdir(tmpdir) if !File.exists?(tmpdir)
  tname = tmpdir + "/" + name
  dna = isDNA?(fasta)
  aliHash = aliasFasta(fasta, nil, tname, opt.trim)
  fasta2Nexus(tname, dna, tname + ".nex")
  out = File.new("#{tname}.nex", "a+")
  if (opt.outgroup)
    aliHash.keys.each {|key|
      out.print "Outgroup #{key};\n" if (aliHash[key] == opt.outgroup)
    }
  end
  if (opt.algorithm == "pars")
    out.print "Set Criterion=parsimony;\n"
    if (opt.noboot)
      out.print "hsearch;\n"
    else
      out.print "boot nreps=#{opt.numboot} keepall=y;\n"
    end
  elsif (opt.algorithm == "ml")
    out.print "Set Criterion=likelihood;\n"
    if (opt.noboot)
      out.print "hsearch;\n"
    else
      out.print "boot nreps=#{opt.numboot} keepall=y;\n"
    end
  elsif (opt.algorithm == "nj")
    out.print "Set Criterion=distance;\n"
    if (opt.noboot)
      out.print "nj;\n"
    else
      out.print "boot nreps=#{opt.numboot} search=nj keepall=y;\n"
    end
  else
    out.print("hsearch;\n")
  end
  
  out.print "savetrees from=1 to=1 format=phylip file=#{tmpdir}/out.tree;\n"
  out.print "quit;\n"
  out.close
  system("paup #{tname}.nex")
  tree = NewickTree.fromFile("#{tmpdir}/out.tree")
  tree.fixPhylip
  tree = estimateMLBranchLengths(tree, tname, tmpdir) if (opt.estimate)
  tree.unAlias(aliHash)
  if (opt.outgroup)
    outNode = tree.findNode(opt.outgroup)
    if (outNode.nil?)
      STDERR.printf("taxon #{opt.outgroup} not found in tree!\n")
    else
      tree = tree.reroot(outNode)
    end 
  elsif (!opt.unrooted)
    tree = tree.midpointRoot
  end  
  tree.write("#{name}_#{opt.algorithm}.tree")
  tree.draw("#{name}_#{opt.algorithm}.tree.pdf")
  cleanup(tmpdir)
}
