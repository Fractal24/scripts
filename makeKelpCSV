#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'GridComputing'
require 'rubygems'
require 'csv'
require 'DBwrapper'
require 'Btab'

opt = OpenStruct.new
opt.prefix = "/home/jbadger/EVOL"
opt.db = "phytoest.db"
opt.coverage = 0.75

o = OptionParser.new
o.banner << " btab [...btab]"
o.on("-c ", "--coverage ", Float,
  "minimum align coverage (default #{opt.coverage})") {|t| opt.coverage = t}
o.on("-d ", "--db ", String, "path name for databases (#{opt.db})") {|t| opt.db = t}
o.on("-n ", "--name ", String, "db path name (#{opt.prefix})") {|t| opt.prefix = t}

begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

db = SQLite.new(opt.prefix + "/" + opt.db)
combodb = SQLite.new(opt.prefix + "/combodb.db")
species = Hash.new

def findSpecies(db, combodb, name)
  [db, combodb].each {|d|
    query = "SELECT taxonomy FROM apis_proteins WHERE protein_name = '#{name}'"
    tax = d.get(query)
    return tax[0].gsub(",","").split("; ").last if (!tax.nil?)
  }
  return nil
end

print ["Name", "Length", "Match", "Coverage", "Evalue", "Align %ID", "Species"].to_csv

ARGV.each {|btab|
  Btab.new(btab).each {|query|
    match = query.matches.first
    slen = (match.srange.first - match.srange.last).abs
    qlen = (match.qrange.first - match.qrange.last).abs
    name, contig = match.name.split("-",2)
    species[contig] = findSpecies(db, combodb, match.name) if species[contig].nil?
    coverage = qlen.to_f/query.length
    aid = match.percentId*query.length/slen
    aid = 100 if aid > 100 # fix rounding errors
    if (coverage > opt.coverage)
      print [query.name, query.length, match.name, (coverage*100).to_i/100.0, 
             match.evalue, aid, species[contig]].to_csv
    end
  }
}

