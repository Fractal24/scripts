#!/usr/bin/env ruby

require 'rubygems'
require 'mysql'
require 'trollop'

ARGV.push("--help") if ARGV.empty?
opts = Trollop::options do
  banner File.basename($0)
  opt :input, "ids to retrieve data for", :type => :strings, :required=> true
  opt :file, "id(s) are files, not record ids"
  opt :contig, "use contig as search id"
  opt :database, "protein database", :default=>"phylodb", :type=>:string
  opt :everything, "return for all contigs"
  opt :species, "use species as search id"
  opt :name, "use (exact) sequence name as search id"
  opt :form, "use contig form as search id"
  opt :host, "database host", :default=>"mysql-lan-pro", :type=>:string
  opt :taxonomy, "use taxonomy as search id"
  opt :molecule, "return full DNA molecules"
  opt :rna, "return rRNAs, not proteins"
  opt :transcripts, "return transcripts, not proteins"
end

if opts.file
  ids = []
  opts.input.each do |file|
    File.new(file).each do |line|
      ids.push(line.split(" ").first)
    end
  end
else
  ids = opts.input
end

db = Mysql.new(opts.host, "access", "access", opts.database)

# quotes single quotes, etc. for SQL usage
class String
  # quotes single quotes, etc. for SQL usage
  def quote
    return self.gsub(/\\/, '\&\&').gsub(/'/, "''")
  end
  # formats string as fasta record
  def to_fasta(header, len = 60)
    return ">#{header}\n#{self.gsub("*","").gsub(Regexp.new(".{1,#{len}}"), "\\0\n")}"
  end
end

def flag_string(flag_num)
  flag_num = flag_num.to_i
  if flag_num == 1 || flag_num == 2
    "kegg"
  elsif flag_num == 5
    "chloro"
  elsif flag_num == 6
    "mito"
  else
    "rest"
  end
end


inList = "("
ids.each do |id|
  if (opts.species)
    query = "SELECT name FROM contigs WHERE species LIKE '%#{id.quote}%'"
  elsif (opts.taxonomy)
    query = "SELECT name FROM contigs WHERE taxonomy LIKE '%#{id.quote}%'"
  elsif (opts.form)
    query = "SELECT name FROM contigs WHERE form LIKE '%#{id.quote}%'"
  elsif (opts.contig)
    query = "SELECT name FROM contigs WHERE name LIKE '%#{id.quote}%'"
  end
  if (!opts.name)
    db.query(query).each do |row|
      inList += "'" + row[0].quote + "',"
    end
  else
    inList += "'" + id.quote + "',"
  end
end
inList.chop!
inList += ")"

if (opts.transcripts)
  query = "SELECT p.seguid, p.name, t.seq, annotation, species, strain, c.taxon_id, p.protein_flag FROM proteins AS p "
  query += "LEFT JOIN contigs AS c on c.name = p.contig_name "
  query += "LEFT JOIN transcripts AS t on t.name = p.name "
  query += "WHERE p.contig_name IN #{inList}"
elsif (opts.rna)
  query = "SELECT r.name, r.name, r.seq, annotation, species, strain, c.taxon_id FROM rrnas AS r "
  query += "LEFT JOIN contigs AS c on c.name = r.contig_name "
  query += "WHERE r.contig_name IN #{inList}"
elsif (opts.molecule)
  query = "SELECT name, name, seq, form, species, strain, taxon_id, contig_flag FROM contigs AS c "
  query += "WHERE name IN #{inList}"
elsif (opts.name)
  query = "SELECT p.seguid, p.name, p.seq, annotation, species, strain, c.taxon_id, p.protein_flag FROM proteins AS p "
  query += "LEFT JOIN contigs AS c on c.name = p.contig_name "
  query += "WHERE p.name IN #{inList}"
else
  query = "SELECT p.seguid, p.name, p.seq, annotation, species, strain, c.taxon_id, p.protein_flag FROM proteins AS p "
  query += "LEFT JOIN contigs AS c on c.name = p.contig_name "
  query += "WHERE p.contig_name IN #{inList}"
end

db.query(query).each do |row|
  seguid, seq_name, seq, ann, species, strain, taxon_id, flag = row
  species += " " + strain if strain.to_s != ""
  header = seguid + " " + seq_name + " <<" + ann.to_s + ">> {" + species + "} " + taxon_id.to_s
  header += " " + flag_string(flag) if flag
  begin
    print seq.to_fasta(header, 60)
  rescue
    STDERR << "No sequence for " << seq_name << ". Skipping...\n"
  end
end




