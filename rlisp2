#!/usr/bin/env ruby

require 'readline'

class Rlisp
  OPERATORS = %i[== != < <= > >= + - * /]

  def initialize(ext = {})
    @quit = false
    @env = Hash.new

    OPERATORS.inject({}) do |scope, operator|
      @env.merge!(operator => lambda { |*args| args.inject(&operator) })
    end
    DATA.each do |line|
      run(line)
    end
    specials = [:quote, :define, :quit, :lambda, :if]
    comp = proc{ |s| (@env.keys + specials).grep( /^#{Regexp.escape(s)}/)}
    Readline.completion_append_character = " "
    Readline.completion_proc = comp
  end

  def run(code)
    self.eval parse(code)
  end

  def parse(program)
    read_from_tokens(tokenize(program))
  end

  def tokenize(chars)
    chars
      .gsub(/\s\s+/, ' ')
      .gsub('(', ' ( ')
      .gsub(')', ' ) ')
      .gsub("'", " ' ")
      .gsub('"', ' " ')
      .split(' ')
  end

  def read_from_tokens(tokens)
    return if tokens.empty?

    quoted = false
    token = tokens.shift
    if "'" == token
      quoted = true
      token = tokens.shift
    end
    if '(' == token
      list = []
      while tokens.first != ')'
        list << read_from_tokens(tokens)
      end
      tokens.shift
      list = [:quote, list] if quoted
      list
    elsif '"' == token
      string = ""
      while tokens.first != '"'
        string += " " if string != ""
        string += tokens.shift.to_s 
      end
      tokens.shift
      string
    elsif ')' == token
      raise 'unexpected )'
    else
      if quoted
        [:quote, atom(token)]
      else
        atom(token)
      end
    end
  end

  def atom(token)
    if token[/\.\d+/]
      token.to_f
    elsif token[/\d+/]
      token.to_i
    else
      token.to_sym
    end
  end

  def eval(exp, env = @env)
    if exp.is_a? Numeric
      exp
    elsif exp.is_a? String
      exp
    elsif exp.is_a? Symbol
      if exp[0] == "."
      else
        env[exp]
      end
    elsif exp[0] == :quote
      exp[1]
    elsif exp[0] == :if
      _, test, conseq, alt = exp
      exp = eval(test, env) ? conseq : alt
      eval(exp, env)
    elsif exp[0] == :define
      _, var, e = exp
      if (var.is_a? Array)
        name = var.shift
        env[name] = lambda { |*args|
          self.eval(e, env.merge(Hash[var.zip(args)])) }
      else
        env[var] = eval(e, env)
      end
    elsif exp[0] == :lambda
      _, params, e = exp
      lambda { |*args| self.eval(e, env.merge(Hash[params.zip(args)])) }
    elsif exp[0] == :ruby
      _, params, e = exp
      procstring = "->(#{params.collect{|x| x.to_s}.join(',')}) {#{e}}"
      Kernel.eval(procstring)
    elsif exp[0] == :quit
      @quit = true
    else
      code = eval(exp[0], env)
      args = exp[1..-1].map{ |arg| eval(arg, env) }
      code.(*args)
    end
  end

  def repl(prompt = '> ')
    while !@quit
      line = Readline::readline(prompt)
      break if line.nil?
      Readline::HISTORY.push(line)
      begin
        result = run(line)
        print result.to_s+"\n" if !@quit
      rescue Exception => e
        p e
      end
    end
  end
end


rlisp = Rlisp.new
rlisp.repl

__END__
(define list (ruby (*list) "Array(list)"))
(define car (ruby (list) "list.first"))
(define cdr (ruby (list) "list.drop 1"))
(define null? (ruby (list) "list.empty?"))
(define cons (ruby (e cell) "[e] + cell"))
(define map (ruby (fn list) "list.map {|x| fn.call x}"))
(define reduce (ruby (fn *args) "if args.size == 1;args[0].reduce &fn;else;args[1].reduce args[0],&fn;end"))
(define succ (ruby (x) "x.succ"))
(define class (ruby (x) "x.class"))
(define max (ruby (list) "list.max"))
(define min (ruby (list) "list.min"))
(define (range x y) (if (< x y) (cons x (range (+ 1 x) y)) (list)))
(define (positive? x) (> x 0))
(define (negative? x) (< x 0))
