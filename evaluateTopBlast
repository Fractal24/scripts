#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'dm-core'
require 'ostruct'
require 'ApisDB'
require 'ComboDB'
require 'ZFile'
require 'bio'

opt = OpenStruct.new

opt.host = "mysql://access:access@mysql-lan-pro"
opt.storage = "misc_apis"
opt.proteindb = "phylodb"

ARGV.options do |opts|
  opts.banner << " blast-file metasim-reads.fa"
  opts.on("-p ", "--proteindb ", String, "protein database (default #{opt.proteindb})") {|t| opt.proteindb = t}
  opts.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|t| opt.storage = t}
  opts.on("-h ", "--host ", String, "database host (default #{opt.host})") {|t| opt.host = t}
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size != 2 )
    STDERR << opts
    exit(1)
  end
end

blast, reads = ARGV

DataMapper.setup(:default, opt.host + "/" + opt.storage)
DataMapper.setup(:combodb, opt.host + "/" + opt.proteindb)

STDERR << "Loading Taxonomy...\n"
tax = Hash.new
orgs = Hash.new
Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(reads)).each do |seq|
  if (seq.definition =~/SOURCE_1=\"([^\"]*)\"/)
    org, rest = $1.split(" {", 2)
    org, rest = org.split(/mega plasmid|plasmid|chromosome/, 2)
    sp, rest = org.split(" ")
    sp = "Ruegeria" if sp ==  "Silicibacter"
    if (tax[sp].nil?)
      con = repository(:combodb) {Contig.first(:species => org)}
      if (con.nil?)
        STDERR << "Can't find taxonomy for " << org << "...\n"
        tax[sp] = "Unknown"
      else
        tax[sp] = con.taxonomy.split("; ")
      end
    end
    orgs[seq.entry_id] = sp
  end
end

STDERR << "Evaluating BLAST...\n"
wrong = Hash.new

id = nil
needHit = false

tx = nil
count = 0
File.new(blast).each do |line|
  if (line =~/Query=/)
    q, id = line.chomp.split(" ")
    needHit = true
    tx = nil
  elsif (line =~/\{([^;]*);\}/ && needHit)
    needHit = false
    sp, rest = $1.split(" ")
    tx = tax[sp]
    if (!tx.nil?)
      count += 1
      ctax = tax[orgs[id]]
      levels = ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus"]
      levels.size.times do |i|
        if (ctax[i] != tx[i])
          wrong[levels[i]] = File.new("wrong_#{levels[i]}_#{reads}.txt", "w") if (!wrong[levels[i]])
          wrong[levels[i]].printf("%s\t%s\n", tx[i], ctax[i])
        end
      end
    end
  end
end

wrong.keys.each do |key|
  wrong[key].close
end

STDERR << count << "\n"