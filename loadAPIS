#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'date'
require 'Btab'
require 'bio'

ARGV.options {|opts|
  opts.banner << " apis-dir [apis-dir...]"
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size < 1)
    STDERR.puts opts
    exit(1)
  end
}

alignment_txt = File.new("alignment.txt", "w")
annotation_txt = File.new("annotation.txt", "w")
blast_txt = File.new("blast.txt", "w")
classification_txt = File.new("classification.txt", "w")
dataset_txt = File.new("dataset.txt", "w")
sequence_txt = File.new("sequence.txt", "w")
tree_txt = File.new("tree.txt", "w")

list = Hash.new

ARGV.each {|dir|
  dataset = File.basename(dir)
  dataset_txt.printf("%s\t%s\t%s\t%s\n", dataset, ENV["USER"],  Date.today.to_s,
                     @comment)
  if File.exists?(dir + "/" + "ann.pep")
    STDERR.printf("Loading sequences for %s...\n", dataset)
    Bio::FlatFile.new(Bio::FastaFormat, File.new(dir + "/" + "ann.pep")).each {|seq|
      list[seq.entry_id] = true
      name, annotation = seq.definition.split(" ", 2)
      sequence_txt.printf("%s\t%s\t%s\t%d\n", name, dataset, seq.seq, 1)
      if (!annotation.nil? && annotation.length > 3)
        annotation_txt.printf("%s\t%s\t%s\t%s\n", name, dataset, annotation, "APIS")
      end
    }
  else
    STDERR.printf("Can't find #{dir}/ann.pep!\n")
    exit(1)
  end
  STDERR.printf("Loading blasts for %s...\n", dataset)
  list.keys.each {|seqname|
    blast = "#{dir}/blast/#{seqname}.blastp.btab"
    next if (!File.exists?(blast))
    count = 0
    Btab.new(blast).each {|query|
      query.each {|match|
        next if match.evalue > 1e-9
        count += 1
        break if count == 50
        blast_txt.printf("%s\t%s\t%s\t%s\t%d\t%d\t%d\t%d\t%d\t%.1f\t%.1f\t%d\t%8.3e\n",
                         query.name, dataset, match.name, match.desc, 
                         match.len, match.qrange.first + 1, 
                         match.qrange.last + 1, match.srange.first + 1,
                         match.srange.last + 1, match.percentId, match.percentSim,
                         match.score, match.evalue)
      }
    }
  }
  STDERR.printf("Loading alignments for %s...\n", dataset)
  list.keys.each {|seqname|
    afa = "#{dir}/alignments/#{seqname}.afa"
    next if (!File.exists?(afa))
    Bio::FlatFile.new(Bio::FastaFormat, File.new(afa)).each {|seq|
      name, annotation = seq.definition.split(" ", 2)
      alignment_txt.printf("%s\t%s\t%s\t%s\t%s\n", File.basename(afa, ".afa"), 
                            dataset, name, annotation, seq.seq)
    }
  }
  STDERR.printf("Loading trees for %s...\n", dataset)
  list.keys.each {|seqname|
    tre = "#{dir}/trees/#{seqname}.tree"
    next if (!File.exists?(tre))
    tree = File.read(tre)
    tree_txt.printf("%s\t%s\t%s\n", File.basename(tre, ".tree"), dataset, tree.chomp)
  }
  STDERR.printf("Loading classifications for %s...\n", dataset)
  list.keys.each {|seqname|
    nei = "#{dir}/neighbors/#{seqname}.nei"
    next if (!File.exists?(nei))
    classification_txt.printf("%s\t%s", File.basename(nei, ".nei"), dataset)
    cl = File.new(nei).read.split("\n")
    next if cl.nil? || cl[0].nil?
    first = cl[0].split("\t")
    if (cl[1].nil?)
      second = nil
    else
      second = cl[1].split("\t")
    end
    mixed = false
    7.times {|level|
      mixed = true if first[level] == "Mixed"
      first[level] = "Mixed" if mixed
      if (first[level] == "Mixed" || second.nil? || first[level] == second[level])
        outgroup = 0
      else
        outgroup = 1
      end
      classification_txt.printf("\t%s\t%d", first[level], outgroup)
    }
    classification_txt.printf("\n")
  }
}

alignment_txt.close
annotation_txt.close
blast_txt.close
classification_txt.close
dataset_txt.close
sequence_txt.close
tree_txt.close
