#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'dm-core'
require 'ostruct'
require 'ApisDB'
require 'ComboDB'
require 'ZFile'
require 'bio'

opt = OpenStruct.new

opt.host = "mysql://access:access@mysql-lan-pro"
opt.proteindb = "phylodb"

ARGV.options do |opts|
  opts.banner << " megan-read-taxid.txt metasim-reads.fa"
  opts.on("-p ", "--proteindb ", String, "protein database (default #{opt.proteindb})") {|t| opt.proteindb = t}
  opts.on("-h ", "--host ", String, "database host (default #{opt.host})") {|t| opt.host = t}
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size != 2 )
    STDERR << opts
    exit(1)
  end
end

megan, reads = ARGV

DataMapper.setup(:default, opt.host + "/" + opt.proteindb)

STDERR << "Loading Taxonomy...\n"
tax = Hash.new
orgs = Hash.new
Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(reads)).each do |seq|
  if (seq.definition =~/SOURCE_1=\"([^\"]*)\"/)
    org, rest = $1.split(" {", 2)
    org, rest = org.split(/mega plasmid|plasmid|chromosome/, 2)
    if (!tax[org])
      con = Contig.first(:species => org)
      if (con.nil?)
        STDERR << "Can't find taxonomy for " << org << "...\n"
        tax[org] = "Unknown"
      else
        tax[org] = con.taxonomy.split("; ")
      end
    end
  end
  tax[seq.entry_id] = tax[org]
end


STDERR << "Evaluating MEGAN...\n"
wrong = Hash.new
taxidtax = Hash.new
counts = 0
File.new(megan).each do |line|
  contig, taxid = line.chomp.gsub(",","").split(" ")
  ctax = tax[contig]
  next if taxid == "-1"
  if (!taxidtax[taxid])
    con =  Contig.first(:taxon_id => taxid)
    next if con.nil?
    taxidtax[taxid] = con.taxonomy.split("; ")
  end
  taxcall = taxidtax[taxid]
  levels = ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus"]
  next if ctax.nil?
  counts += 1
  levels.size.times do |i|
    if (ctax[i] != taxcall[i])
      wrong[levels[i]] = File.new("MEGAN_wrong_#{levels[i]}_#{reads}.txt", "w") if (!wrong[levels[i]])
      wrong[levels[i]].printf("%s\t%s\n", taxcall[i], ctax[i])
    end
  end
end

wrong.keys.each do |key|
  wrong[key].close
end

cout << counts << " reads classified\n"