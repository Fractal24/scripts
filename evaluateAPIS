#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'dm-core'
require 'ostruct'
require 'ApisDB'
require 'ComboDB'
require 'ZFile'
require 'bio'

opt = OpenStruct.new

opt.host = "mysql://access:access@mysql-lan-pro"
opt.storage = "misc_apis"
opt.proteindb = "phylodb"

ARGV.options do |opts|
  opts.banner << " dataset metasim-reads.fa"
  opts.on("-p ", "--proteindb ", String, "protein database (default #{opt.proteindb})") {|t| opt.proteindb = t}
  opts.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|t| opt.storage = t}
  opts.on("-h ", "--host ", String, "database host (default #{opt.host})") {|t| opt.host = t}
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size != 2 )
    STDERR << opts
    exit(1)
  end
end

dataset, peps = ARGV

DataMapper.setup(:default, opt.host + "/" + opt.storage)
DataMapper.setup(:combodb, opt.host + "/" + opt.proteindb)

STDERR << "Loading Taxonomy...\n"
tax = Hash.new
orgs = Hash.new
Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(peps)).each do |seq|
  if (seq.definition =~/SOURCE_1=\"([^\"]*)\"/)
    org, rest = $1.split(" {", 2)
    org, rest = org.split(/mega plasmid|plasmid|chromosome/, 2)
    if (tax[org].nil?)
      con = repository(:combodb) {Contig.first(:species => org)}
      if (con.nil?)
        STDERR << "Can't find taxonomy for " << org << "...\n"
        tax[org] = "Unknown"
      else
        tax[org] = con.taxonomy.split("; ")
      end
    end
    orgs[seq.entry_id] = org
  end
end

STDERR << "Evaluating APIS...\n"
wrong = Hash.new
Classification.all(:dataset_id => dataset).each do |apis|
  contig, start, stop = apis.seq_name.split("_")
  taxcall = [apis.kingdom, apis.phylum, apis.classname, apis.order, apis.family, apis.genus]
  ctax = tax[orgs[contig]]
  levels = ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus"]
  levels.size.times do |i|
    if (ctax[i] != taxcall[i])
      wrong[levels[i]] = File.new("wrong_#{levels[i]}_#{peps}.txt", "w") if (!wrong[levels[i]])
      wrong[levels[i]].printf("%s\t%s\n", taxcall[i], ctax[i])
    end
  end
end

wrong.keys.each do |key|
  wrong[key].close
end