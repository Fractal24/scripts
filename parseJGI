#!/usr/bin/env ruby

require 'rubygems'
require 'bio'
require 'mysql'
require 'optparse'
require 'ostruct'
require 'digest/sha1'

opt = OpenStruct.new
o = OptionParser.new
o.banner << " abbr species gff fasta"
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size != 4)
  STDERR << o
  exit(1)
end

abbr, species, gff, fasta = ARGV

db=Mysql.new("mysql-lan-pro", "apis", "apis_user", "phylodb")


# return taxonomy by recursively working up taxonomy table
def recurseTaxonomy(db, current)
  name, parent, rank = db.query("SELECT name, parent_id, rank FROM taxonomy WHERE taxon_id=#{current}").fetch_row
  if (parent == "1")
    []
  else
    if ["superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species"].include?(rank)
      db.query("UPDATE taxonomy SET used_taxon=1 WHERE taxon_id = #{current}")
      recurseTaxonomy(db, parent).to_a + [name] 
    else
      recurseTaxonomy(db, parent)
    end
  end
end

# calculate seguid for protein
class String
  def seguid
    final = self.upcase.scan(/[A-Z]/).join
    [Digest::SHA1.digest(final)].pack("m").chomp("=\n")
  end
end

tinfo =  db.query("SELECT * FROM taxonomy WHERE name = '#{species}'").fetch_hash
if (tinfo.nil?)
  STDERR << "I can't add #{species} to phyloDB as it has no taxon id in the taxonomy table!"
  exit(1)
else
  taxonomy = recurseTaxonomy(db, tinfo["taxon_id"])
  if (taxonomy.size != 7)
    printf("Taxonomy: %s doesn't have seven ranks!", taxonomy.join("; "))
    exit(1)
  end
end
db.close


exons = Hash.new
STDERR << "Loading GFF File...\n"
Bio::GFF.new(File.read(gff)).records.each do |rec|
  if (rec.feature == "exon")
    exons[rec.seqname] = Hash.new if !exons[rec.seqname]
    tid = rec.attributes["transcriptId"]
    if (tid.nil?)
      STDERR << "Cannot find transcriptID in " << rec.to_s << "\n"
      exit(1)
    end
    exons[rec.seqname][tid] = [] if (!exons[rec.seqname][tid]) 
    exons[rec.seqname][tid].push([rec.start.to_i, rec.end.to_i, rec.strand])
  end
end

if (!File.exists?("contigs.txt"))
  contigs_out = File.new("contigs.txt", "w")
  proteins_out = File.new("proteins.txt", "w")
  transcripts_out = File.new("transcripts.txt", "w")
else
  STDERR << "You already have a contigs.txt. I don't want to overwrite it\n"
  exit(1)
end


STDERR << "Loading Contigs...\n"
Bio::FlatFile.new(Bio::FastaFormat, File.new(fasta)).each do |seq|
  name = seq.entry_id
  if (name=~/^scaffold|^contig/i)
    name = abbr + "_" + name
  end
  updated = Time.now
  row = [name, species, "", tinfo["taxon_id"], taxonomy.join("; "), "", "", 
    "scaffold", seq.seq.upcase,updated, 4, ""]
  contigs_out.print row.join("\t") + "\n"
  transcripts = Hash.new
  if (exons[seq.entry_id])
    exons[seq.entry_id].keys.sort.each do |tid|
      transcripts[tid] = ""
      exons[seq.entry_id][tid].each do |exon|
        transcripts[tid] += seq.seq[exon[0] -1 .. exon[1] - 1]
      end
    end 
    transcripts.keys.sort.each do |tid|
      if (exons[seq.entry_id][tid].first[2] == "+")
        pep = Bio::Sequence::NA.new(transcripts[tid]).translate
      else
        pep = Bio::Sequence::NA.new(transcripts[tid]).complement.translate
      end
      row = [tid.to_s + "-" + name, name, "", pep, tinfo["taxon_id"],
        4, pep.seguid]
      proteins_out.print row.join("\t") + "\n"
      row = [tid.to_s + "-" + name, name, transcripts[tid], 4]
      transcripts_out.print row.join("\t") + "\n"
    end
  end
end
contigs_out.close
proteins_out.close
transcripts_out.close