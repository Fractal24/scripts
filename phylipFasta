#!/usr/bin/env ruby

require 'rubygems'
require 'trollop'
require 'bio'
require 'apis_lib'
require 'Newick'
require 'fpdf'

origARGV = ARGV.dup # keep unparsed copy for grid

ARGV.push("--help") if ARGV.empty?
opts = Trollop::options do
  banner File.basename($0)
  opt :input, "fasta alignment(s)", :required =>true, :type =>:strings
  opt :bootstrap, "number of bootstraps (or 0 to not bootstrap)", :default=>100, :type=>:integer
  opt :estimate, "estimate branch lengths with puzzle"
  opt :algorithm, "algorithm from choices: nj, pars, ml", :default=>"nj", :type =>:string
  opt :outgroup, "use specified taxon as outgroup", :type=>:string
  opt :unrooted, "leave tree unrooted"
  opt :project, "run on grid with project number specified", :type=>:string
  opt :pam, "use PAM model"
  opt :gamma, "use gamma distrib. rates"
end

if (opts.algorithm != "pars" && opts.algorithm != "nj" && opts.algorithm != "ml")
  STDERR.printf("only pars, ml, and nj are supported\n")
  exit(1)
end

if (opts.project)
  qsystem($0 + " " + origARGV.join(" ").gsub(/ -p [0-9]*/,""), opts.project)
  exit(0)
end

opts.input.each do |fasta|
  name = File.basename(fasta).split(".").first
  tmpdir = ENV["HOME"] + "/.tmp"
  Dir.mkdir(tmpdir) if !File.exists?(tmpdir)
  tmpdir += "/" + name + "_" + Time.now.to_f.to_s
  Dir.mkdir(tmpdir) if !File.exists?(tmpdir)
  tname = tmpdir + "/" + name
  dna = isDNA?(fasta)
  aliHash = aliasFasta(fasta, nil, tname, opts.outgroup, opts.trim)
  fasta2Phylip(tname, "#{tname}.phy")
  File.unlink("#{tmpdir}/infile") if (File.exists?("#{tmpdir}/infile"))
  File.unlink("#{tmpdir}/outfile") if (File.exists?("#{tmpdir}/outfile"))
  File.unlink("#{tmpdir}/outtree") if (File.exists?("#{tmpdir}/outtree"))
  File.rename("#{tname}.phy", "#{tmpdir}/infile")
  
  if (opts.bootstrap > 0)
    odd = (2 * rand(40)) + 1
    system("cd #{tmpdir};echo -e 'R\n#{opts.bootstrap}\nY\n#{odd}\n' | seqboot")
    File.rename("#{tmpdir}/outfile", "#{tmpdir}/infile")
  end
  if (opts.algorithm == "pars")
    if (dna)
      pars = "dnapars"
    else
      pars = "protpars"
    end
    if (opts.bootstrap == 0)
      system("cd #{tmpdir}; echo -e 'Y\n' | #{pars}") 
    else
      odd = (2 * rand(40)) + 1
      system("cd #{tmpdir}; echo -e 'M\n\D\n#{opts.bootstrap}\n#{odd}\n2\nY\n' | #{pars}") 
    end
  elsif (opts.algorithm == "nj")
    if (dna)
      dist = "dnadist"
    else
      dist = "protdist"
    end
    if (opts.bootstrap == 0)
      system("cd #{tmpdir}; echo -e 'Y\n' | #{dist}")
      neighbor = "echo -e 'Y\n' | neighbor"
    else
      system("cd #{tmpdir}; echo -e 'M\nD\n#{opts.bootstrap}\nY\n' | #{dist}")
      odd = (2 * rand(40)) + 1
      neighbor = "echo -e 'M\n#{opts.bootstrap}\n#{odd}\nY\n' | neighbor"
    end
    File.rename("#{tmpdir}/outfile", "#{tmpdir}/infile")
    system("cd #{tmpdir}; #{neighbor}")
  elsif (opts.algorithm == "ml")
    pam = ""
    after = "Y\n"
    if (dna)
      ml = "dnaml"
    else
      ml = "proml"
      pam = "P\nP\n" if (opts.pam)
      pam += "R\n" if (opts.gamma)
    end
    aft = "Y\n"
    aft += "1.41\n9\n" if (opts.gamma)
    if (opts.bootstrap == 0)
      system("cd #{tmpdir}; echo -e '#{pam}#{aft}' | #{ml}") 
    else
      odd = (2 * rand(40)) + 1
      system("cd #{tmpdir};echo -e 'M\n\D\n#{opts.bootstrap}\n#{odd}\n2\n#{pam}#{aft}'|#{ml}") 
    end
  end
 
  if (!opts.noboot)
    File.rename("#{tmpdir}/outtree", "#{tmpdir}/intree")
    File.unlink("#{tmpdir}/outfile")
    system("cd #{tmpdir}; echo -e 'Y\n' | consense")
  end
  File.rename("#{tmpdir}/outtree", "#{tname}.tree")
  tree = NewickTree.fromFile("#{tname}.tree")
  tree.fixPhylip
  tree = estimateMLBranchLengths(tree, tname, tmpdir) if (opts.estimate)
  tree.unAlias(aliHash)
  if (opts.outgroup)
    outNode = tree.findNode(opts.outgroup)
    if (outNode.nil?)
      STDERR.printf("taxon #{opts.outgroup} not found in tree!\n")
    elsf (!opts.unrooted)
      tree = tree.reroot(outNode)
    end
  else
    tree = tree.midpointRoot
  end
  if (!opts.gamma)
    tree.write("#{name}_#{opts.algorithm}.tree")
    tree.draw("#{name}_#{opts.algorithm}.tree.pdf")
  else
    tree.write("#{name}_#{opts.algorithm}_gamma.tree")
    tree.draw("#{name}_#{opts.algorithm}_gamma.tree.pdf")
  end
  cleanup(tmpdir)
end
