#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'rubygems'
require 'bio'
require 'ZFile'

#For testing in TextMate:
#Dir.chdir("/Users/jbadger/work/hmp")
#ARGV.push("Airways_all_trim.afa")


defaultcolors = {
  "Bacteria; Proteobacteria" => "lightgrey", 
  "Bacteria; Firmicutes" => "red", 
  "Bacteria; Actinobacteria" => "yellow", 
  "Bacteria; Bacteroidetes" => "green",
  "Bacteria; Fusobacteria" => "fuschia", 
  "Bacteria; Spirochaetes" => "aqua",
  "Bacteria; Tenericutes" => "olive", 
  "Bacteria; Deinococcus-Thermus" => "lime",
  "Bacteria; Chloroflexi" => "teal",
  "Bacteria; Chlorobi" => "purple",
  "Bacteria; Synergistetes" => "maroon",
  "Bacteria; Verrucomicrobia" => "brown",
  "Bacteria; Thermotogae" => "cyan",
  "Bacteria; Chlamydiae" => "darkorange", 
  "Bacteria; Aquificae" => "orange",
  "Bacteria; Planctomycetes" => "darkgrey", 
  "Bacteria; Acidobacteria" => "silver",
  "Bacteria; Nitrospirae" => "grey"
}

def generateRandomColor(mix) 
  red = rand(256)
  green = rand(256)
  blue = rand(256)
  red = (red + mix[0]) / 2
  green = (green + mix[1]) / 2
  blue = (blue + mix[2]) / 2
  color = "#" + red.to_s(base=16) + green.to_s(base=16) + blue.to_s(base=16)
  return color.upcase
end
  
opt = OpenStruct.new
o = OptionParser.new
o.banner << " alignment.afa [alignment.afa...]"
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

seen = Hash.new
colors = Hash.new
ARGV.each {|afa|
  taxinfo = Hash.new
  name = File.basename(afa, ".afa")
  outAfa = File.new(name + ".out", "w")
  Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(afa)).each do |seq|
    sname = seq.entry_id
    tax = seq.definition.split(" ")[1]
    next if tax =~/^unclassified/
    if (tax)
      tax = tax.split(";")
      taxinfo[sname] = tax[0] + "; " + tax[1]
      if (defaultcolors[taxinfo[sname]])
        colors[taxinfo[sname]] = defaultcolors[taxinfo[sname]]
      else
        colors[taxinfo[sname]] = generateRandomColor([255,255,255])
      end
    end
    outAfa.print seq.seq.to_fasta(seq.definition.gsub(seq.entry_id, sname), 60) if (!seen[sname])
    seen[sname] = true
  end
  outAfa.close
  tree = name + ".tree"
  if (!File.exists?(tree))
    system("FastTree -nt -gtr  < #{name}.out > #{tree}")
  end
  File.unlink(name + ".out")
  infotmp = name + ".infotmp"
  system("treeinfo.pl #{tree} > #{infotmp}")
  info = name + ".info"
  infof = File.new(info, "w")
  File.new(infotmp).each {|line|
    fields = line.split(" ", 4)
    num, dist, type, sp = line.chomp.split("\t")
    if (line =~/^font/)
      line = "font\t1.0\tVerdana\t#000000\n"
    elsif (type == "r")
      if (taxinfo[sp])
        line = num + "\t" + dist + "\t" + type + "\t" + sp + "\t" + taxinfo[sp] + "\n"
      else
        line = num + "\t" + dist + "\t" + "q" + "\t" + sp + "\n"
      end
    end
    infof.print line
  }
  infof.printf("ttclr\tq\torange\tblue\n")
  
  colors.keys.each {|key|
    infof.printf("htax\t%s\t%s\n", key, colors[key])
  }
  infof.close
  File.unlink(infotmp)
  svgtmp = name + ".svgtmp"
  system("treeinfo2svg.pl #{info} > #{svgtmp}")
  svg = name + ".svg"
  svgf = File.new(svg, "w")
  y = -1500
  File.new(svgtmp).each {|line|
    if line =~/<\/svg>/
      colors.keys.each {|key|
        y += 2100
        svgf.printf("<rect x=\"1000\" y=\"#{y}\" width=\"60000\"  height=\"3000\" fill=\"#{colors[key]}\"/>
        <text x=\"1000\" y=\"#{y+2000}\" font-size=\"2900\" font-weight=\"bold\" font-family=\"Verdana\" fill=\"black\">#{key}</text>\n")
      }
    else
      svgf.print line
    end
  }
  svgf.printf("<text x=\"7300\" y=\"700\" font-size=\"500\" font-weight=\"bold\" font-family=\"Verdana\" 
  fill=\"black\">#{name}</text>")
  svgf.printf("</svg>\n")
  svgf.close
  File.unlink(svgtmp)
  pdf = name + ".pdf"
  system("svg2pdf  #{svg} > #{pdf}")
}