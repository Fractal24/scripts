#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'rubygems'
require 'bio'
require 'ZFile'
require 'fastercsv'

#For testing in TextMate:
#Dir.chdir("/Users/jbadger/work/hmp")
#ARGV.push("Airways_all_trim.afa")


defaultcolors = {
  "Bacteria; Proteobacteria" => "lightgrey", 
  "Bacteria; Firmicutes" => "red", 
  "Bacteria; Actinobacteria" => "yellow", 
  "Bacteria; Bacteroidetes" => "green",
  "Bacteria; Fusobacteria" => "lavender", 
  "Bacteria; Spirochaetes" => "aqua",
  "Bacteria; Tenericutes" => "olive", 
  "Bacteria; Deinococcus-Thermus" => "lime",
  "Bacteria; Chloroflexi" => "teal",
  "Bacteria; Chlorobi" => "purple",
  "Bacteria; Synergistetes" => "maroon",
  "Bacteria; Verrucomicrobia" => "brown",
  "Bacteria; Thermotogae" => "cyan",
  "Bacteria; Chlamydiae" => "darkorange", 
  "Bacteria; Aquificae" => "orange",
  "Bacteria; Planctomycetes" => "darkgrey", 
  "Bacteria; Acidobacteria" => "silver",
  "Bacteria; Nitrospirae" => "pink"
}

def generateRandomColor(mix) 
  red = rand(256)
  green = rand(256)
  blue = rand(256)
  red = (red + mix[0]) / 2
  green = (green + mix[1]) / 2
  blue = (blue + mix[2]) / 2
  color = "#" + red.to_s(base=16) + green.to_s(base=16) + blue.to_s(base=16)
  return color.upcase
end
  
opt = OpenStruct.new
o = OptionParser.new
o.banner << " alignment.afa [alignment.afa...]"
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

seen = Hash.new
colors = Hash.new
ARGV.each {|afa|
  taxinfo = Hash.new
  name = File.basename(afa, ".afa")
  outAfa = File.new(name + ".out", "w")
  Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(afa)).each do |seq|
    sname = seq.entry_id
    tax = seq.definition.split(" ")[1]
    next if tax =~/^unclassified/
    if (tax)
      tax = tax.split(";")
      taxinfo[sname] = tax[0] + "; " + tax[1]
      if (defaultcolors[taxinfo[sname]])
        colors[taxinfo[sname]] = defaultcolors[taxinfo[sname]]
      else
        colors[taxinfo[sname]] = generateRandomColor([255,255,255])
      end
    end
    outAfa.print seq.seq.to_fasta(seq.definition.gsub(seq.entry_id, sname), 60) if (!seen[sname])
    seen[sname] = true
  end
  outAfa.close
  tree = name + ".tree"
  if (!File.exists?(tree))
    system("FastTree -nt -gtr  < #{name}.out > #{tree}")
  end
  File.unlink(name + ".out")
  info = name + ".info"
  if (!File.exists?(info))
    STDERR.printf("Making info...\n")
    infotmp = name + ".infotmp"
    system("treeinfo.pl #{tree} > #{infotmp}")
    infof = File.new(info, "w")
    File.new(infotmp).each {|line|
      fields = line.split(" ", 4)
      num, dist, type, sp = line.chomp.split("\t")
      if (line =~/^font/)
        line = "font\t1.0\tVerdana\t#000000\n"
      elsif (type == "r")
        if (taxinfo[sp])
          line = num + "\t" + dist + "\t" + type + "\t" + sp + "\t" + taxinfo[sp] + "\n"
        else
          line = num + "\t" + dist + "\t" + "q" + "\t" + sp + "\n"
        end
      end
      infof.print line
    }
    infof.printf("ttclr\tq\torange\tblue\n")
  
    colors.keys.each {|key|
      infof.printf("htax\t%s\t%s\n", key, colors[key])
    }
    infof.close
    File.unlink(infotmp)
  end
  svg = name + ".svg"
  if (!File.exists?(svg))
    STDERR.printf("Making svg...\n")
    svgtmp = name + ".svgtmp"
    system("treeinfo2svg.pl #{info} > #{svgtmp}")
  
    svgf = File.new(svg, "w")
    y = -1500
    File.new(svgtmp).each {|line|
      if line =~/<\/svg>/
        colors.keys.each {|key|
          y += 2100
          svgf.printf("<rect x=\"1000\" y=\"#{y}\" width=\"60000\"  height=\"3000\" fill=\"#{colors[key]}\"/>
          <text x=\"1000\" y=\"#{y+2000}\" font-size=\"2900\" font-weight=\"bold\" font-family=\"Verdana\" fill=\"black\">#{key}</text>\n")
        }
      else
        svgf.print line
      end
    }
    svgf.printf("<text x=\"7300\" y=\"700\" font-size=\"500\" font-weight=\"bold\" font-family=\"Verdana\" 
    fill=\"black\">#{name}</text>")
    svgf.printf("</svg>\n")
    svgf.close
    File.unlink(svgtmp)
  end
  pdf = name + ".pdf"
  if (!File.exists?(pdf))
    STDERR.printf("Making pdf...\n")
    begin
      system("svg2pdf  #{svg} > #{pdf}")
    rescue
      STDERR.printf("Can't make pdf...\n")
    end
  end
  dist = name + ".dist"
  if (!File.exists?(dist))
    STDERR.printf("Making distance Matrix...\n")
    system("newickDist #{tree} > #{dist}")
  end
  csv = name + ".csv"
  if (!File.exists?(csv))
    STDERR << "Processing distance...\n"
    out = File.new(csv, "w")
    taxa = []
    File.new(dist).each do |line|
      fields = line.chomp.split(" ")
      next if fields.size == 1
      sp = fields.shift
      taxa.push(sp)
    end
    STDERR << "Loading Sequences...\n"
    seqs = Hash.new
    Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(afa)).each do |seq|
      if (!taxinfo[seq.entry_id])
        seqs[seq.entry_id] = seq.seq.gsub("-","").gsub(".","").upcase
      end
    end
    STDERR << "Loading Cluster...\n"
    clstr = name + ".clstr"
    clst = Hash.new
    ccount = Hash.new
    num = 0
    File.new(clstr).each do |line|
      if (line =~/^>Cluster ([0-9]*)/)
        num = $1.to_i
        ccount[num] = 0
      else 
        entry = line.split(" ")[2].split("...").first.gsub(">","")
        clst[entry] = num
        ccount[num] += 1
      end
    end
    ctot = ccount.values.reduce(:+)
    out.print ["Dirk's ID", "Closest Sequenced or HMP", "Phylum", "Closest Tree Distance", 
      "Size of 97% Cluster (out of #{ctot})","Cluster Representative Sequence"].to_csv
    lines = Hash.new
    min = Hash.new
    File.new(dist).each do |line|
      fields = line.chomp.split(" ")
      sp = fields.shift
      if (!taxinfo[sp])
        min[sp] = 1e6
        minTax = ""
        fields.size.times do |i|
          field = fields[i].to_f
          if (taxinfo[taxa[i]] && field < min[sp])
            min[sp] = field
            minTax = taxa[i]
          end
        end
        if (min[sp] < 1e6 && seqs[sp])
          lines[sp] = [sp, minTax, taxinfo[minTax], min[sp], ccount[clst[sp]], seqs[sp]]
        end
      end
    end
    lines.keys.sort {|x, y| min[y] <=> min[x]}.each do |sp|
      out.print lines[sp].to_csv
    end
    out.close
  end
  rooted = name + "_root.tree"
  if (!File.exists?(rooted))
    STDERR << "Rooting #{tree}...\n"
    system("newickReroot #{tree} > #{rooted}")
  end
}