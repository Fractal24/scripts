#!/usr/bin/env ruby

$VERBOSE = false

require 'ostruct'
require 'optparse'
require 'rubygems'
require 'bio'
opt = OpenStruct.new

opt.evalue = 0.1

ARGV.options {|opts|
  opts.banner << " pep pep [..pep]"
  opts.on("-e ", "--evalue ", Float, 
          "evalue cutoff (default #{opt.evalue})") {|t| opt.evalue = t}
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size < 2)
    STDERR.puts opts
    exit(1)
  end
}

def merge(clusters, pvalue, genome)
  clusters.each {|c1|
    clusters.each {|c2|
      if (c1 - c2 != c1) #overlap
        ctmp = (c1 + c2).uniq
        seen = Hash.new
        bad = false
        ctmp.each {|pep|
          if (seen[genome[pep]])
            bad = true
          else
            seen[genome[pep]] = true
          end
          if (!bad)
            c1 = ctmp.dup
            clusters.delete(c2)
          end
        }
      end
    }
  }
end


plen = Hash.new
score = Hash.new

outName = ARGV[0].to_s + ".mcl"
out = File.new(outName, "w")

STDERR.printf("Loading Genomes...\n")
ARGV.each {|pep|
  Bio::FlatFile.new(Bio::FastaFormat, File.new(pep)).each {|seq|
    key = seq.entry_id + "__" + pep
    score[key] = Hash.new
    score[key][key] = 10
    plen[key] = seq.length
    out.printf("%s\t%s\t%8.3f\n",key,key,score[key][key])
  }
}


STDERR.printf("Loading Pairwise Clusters...\n")
ARGV.each {|pep1|
  ARGV.each {|pep2|
    next if pep1 == pep2
    vs = pep1 + "_vs_" + pep2
    rvs = pep2 + "_vs_" + pep1
    if (!File.exists?(vs + ".recip"))
      opts = "-e #{opt.evalue}"
      if (File.exists?("#{vs}.blast"))
        system("bestRecip #{opts} #{vs}.blast #{rvs}.blast > #{vs}.recip")
      elsif (File.exists?("#{vs}.blastp"))
        system("bestRecip #{opts} #{vs}.blastp #{rvs}.blastp > #{vs}.recip")
      elsif (File.exists?("#{vs}.blastp.btab"))
        system("bestRecipBtab #{opts} #{vs}.blastp.btab #{rvs}.blastp.btab > #{vs}.recip")
      else
        STDERR.printf("Can't find any blast for #{vs}!\n")
        exit(1)
      end
    end
    File.new(vs + ".recip").each {|line|
      x, y, p1, p2, orth = line.chomp.split("\t")
      x = x + "__" + pep1
      y = y + "__" + pep2
      if (orth == "yes")
        score[x][y] = -Math.log(p1.to_f + 1e-300)
        score[x][y] = 200 if score[x][y] > 200
        score[y][x] = -Math.log(p2.to_f + 1e-300)
        score[y][x] = 200 if score[y][x] > 200
        out.printf("%s\t%s\t%8.3f\n",x,y,score[x][y])
      end
    }
  }
}
out.close

def averageScore(scoreHash)
  tot = 0
  scoreHash.values.each {|value|
    tot += value
  }
  return tot / scoreHash.keys.size
end

printf("Representative")
ARGV.each {|g|
  printf(",%s", File.basename(g, ".pep"))
}
printf("\n")

def processmcl(out, score, plen, genomes, reps, globalSeen)
  bad = []
  $VERBOSE = nil
  STDERR.printf("Building Multi Clusters...\n")
  `mcl #{out} --abc -o - 2>/dev/null`.split("\n").each {|line|
    fields = line.chomp.split("\t")
    seen = Hash.new
    
    fields.each {|field|
      if (field.class == Array || field.nil?)
        fields.delete(field)
        next
      end
      pep, genome = field.split("__")
      if (seen[genome])
        if (averageScore(score[seen[genome]]) > averageScore(score[field]))
          bad.push(field)
        else
          bad.push(seen[genome])
          seen[genome] = field
        end
      else
        seen[genome] = field
      end
    }
    fields = seen.values.sort {|x, y| plen[y]<=>plen[x]}
    fields.each {|field|
      fields.delete(field) if (globalSeen[field]) 
    }
    if (!fields.empty?)
      longest = fields.first
      reps[longest.split("__").first] = true
      printf("%s", longest.split("__").first)
      genomes.each {|genome|
        if (seen[genome] && !globalSeen[seen[genome]])
          printf(",%s", seen[genome].split("__").first)
          globalSeen[seen[genome]] = true
        else
          printf(",")
        end
      } 
      printf("\n")
    end
  }
  return bad
end

reps = Hash.new

globalSeen = Hash.new

bad = processmcl(outName, score, plen, ARGV, reps, globalSeen)
outName = ARGV[0].to_s + ".mcl"
out = File.new(outName, "w")
bad.each {|x|
  out.printf("%s\t%s\t%8.3f\n",x,x,score[x][x])
  score[x].keys.each {|y|
    out.printf("%s\t%s\t%8.3f\n",x,y,score[x][y]) if (bad.include?(y))
  }
}
out.close
processmcl(outName, score, plen, ARGV, reps, globalSeen)
File.unlink(outName)

STDERR.printf("Writing Pangenome.fa...\n")
out = File.new("Pangenome.fa", "w")
ARGV.each {|pep|
  Bio::FlatFile.new(Bio::FastaFormat, File.new(pep)).each {|seq|
    out.print seq if reps[seq.entry_id]
  }
}
out.close
