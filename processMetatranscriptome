#!/usr/bin/env ruby

require 'rubygems'
require 'dm-core'
require 'optparse'
require 'ostruct'
require 'bio'
require 'Btab'
require 'ZFile'
require 'fastercsv'

opt = OpenStruct.new
o = OptionParser.new
opt.database = false
opt.posmap = false
opt.ali = false

o.banner << " fna btab"
o.on("-d", "--database", "use database") {opt.database = true}
o.on("-a ", "--alias ", String, "alias file ") {|t| opt.ali = t}
o.on("-p ", "--posmap ", String, "posmap file ") {|t| opt.posmap = t}
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size != 2)
  STDERR << o
  exit(1)
end

fna, btab = ARGV
lib = Hash.new
DataMapper.setup(:default, "mysql://access:access@mysql-lan-pro/phylodb_annotation")

annotation = Hash.new
matches = Hash.new
seen = Hash.new
pfam = Hash.new
tigrfam = Hash.new
STDERR << "Loading Btab...\n"
Btab.new(btab).each do |query|
  name = query.name.split(" ").first
  match = query.matches.first
  matches[name] = match.name
  annotation[match.name] = OpenStruct.new
  if (match.desc =~/(\S+)([^\{]*)\{([^\}]*)/)
    annotation[match.name].species = $3.strip
    annotation[match.name].annotation = $2.strip
  end
  seen[match.name] = true
end


if (opt.database)
  STDERR << "Fetching data from database...\n"
  list = seen.keys.reduce(:+)
  query = "SELECT * FROM summary_ann WHERE phylodb_seq_id IN ('#{seen.keys.join("','")}')"
  repository(:default).adapter.select(query).each do |row|
    row = row.to_a
    name = row.shift
    ann = annotation[name]
    ann.taxid, ann.species, ann.taxonomy, ann.annotation, ann.gos, swiss, swiss_ann, cog, cog_ann, ann.phytax, 
    ann.ko, ann.pathway, ann.pfam, ann.pfamAnn, ann.tigrfam, ann.tigrfamAnn = row
    ann.swiss, ann.swiss_ann = swiss, swiss_ann if (!swiss.nil?)
    ann.cog, ann.cog_ann = cog, cog_ann if (!cog.nil?)
    pfam[ann.pfam] = [] if (ann.pfam && !pfam[ann.pfam])
    tigrfam[ann.tigrfam] = [] if (ann.tigrfam && !pfam[ann.tigrfam])
  end
  repository(:default).adapter.select("SELECT pfam, go FROM pfam2go WHERE pfam IN ('#{pfam.keys.join("','")}')").each do |row|
    pfam[row[0]].push(row[1])
  end
  repository(:default).adapter.select("SELECT tigrfams, go FROM tigrfams2go WHERE tigrfams IN ('#{tigrfam.keys.join("','")}')").each do |row|
    tigrfam[row[0]].push(row[1])
  end
  repository(:default).adapter.select("SELECT jcvi, ncbi FROM ncbi WHERE jcvi IN ('#{seen.keys.join("','")}')").each do |row|
    jcvi, ncbi = row
    annotation[jcvi]["ncbi"] = ncbi if (annotation[jcvi])
  end
end


if (opt.ali)
  STDERR << "Loading aliases...\n"
  ZFile.new(opt.ali).each do |line|
    read, alname = line.chomp.split(" ")
    lib[read] = alname.split("_").first
  end
end

libcounts = Hash.new
totcounts = Hash.new

if (opt.posmap)
  STDERR << "Loading posmap...\n"
  ZFile.new(opt.posmap).each do |line|
    contig, read = line.chomp.split(" ")
    libcounts[contig] = Hash.new if libcounts[contig].nil?
    if (opt.ali)
      lread = lib[read]
    else
      lread = read.split("_").first
    end
    if (lread.nil?)
      STDERR << "No library for " << read << "\n"
      next
    end
    libcounts[contig][lread] = 0 if libcounts[contig][lread].nil?
    libcounts[contig][lread] += 1
    totcounts[lread] = 0 if totcounts[lread].nil?
    totcounts[lread] += 1
  end
end

contigs = Hash.new
STDERR << "Loading DNA Info...\n"
Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(fna)).each do |seq|
  seen[seq.entry_id] = true
  if (seq.definition =~/(isogroup[0-9]*)/)
    contigs[seq.entry_id] = $1
  else
    contigs[seq.entry_id] = ""  
  end
end

STDERR << "Writing Spreadsheet...\n"
header = ["Contigs", "Isogroup"]
totcounts.keys.sort.each do |key|
  header.push(key)
end
header.push("Sum")
totcounts.keys.sort.each do |key|
  header.push(key + " Normalized")
end
header.push("JCVI Match ID", "GenBank ID (if present)", "Annotation", "Species", "Taxon Id", "Taxonomy", 
"GOS Cluster", "Phytax Cluster", "Kegg Ortholog", "Kegg Pathway", "SwissProt", 
"SwissProt Ann", "COG", "COG Ann","PFAM","PFAM Ann", "TIGRFAM", 
"TIGRFAM Ann", "GO")
print header.to_csv

libcounts.keys.sort.each do |contig|
  line = [contig, contigs[contig]]
  sum = 0
  totcounts.keys.sort.each do |key|
    line.push(libcounts[contig][key].to_i)
    sum += libcounts[contig][key].to_i
  end
  line.push(sum)
  totcounts.keys.sort.each do |key|
    line.push(libcounts[contig][key].to_i/totcounts[key].to_f)
  end
  ann = annotation[matches[contig]]
  if (!ann.nil?)
    ann.go = (pfam[ann.pfam].to_a + tigrfam[ann.tigrfam].to_a).sort.uniq.join("; ")
    ann.annotation = "" if (ann.annotation.nil? || ann.annotation[0] == "{")
    line.push(matches[contig], ann.ncbi, ann.annotation, ann.species, ann.taxid, ann.taxonomy, 
      ann.gos, ann.phytax,ann.ko, ann.pathway, ann.swiss, ann.swiss_ann, ann.cog, ann.cog_ann, 
      ann.pfam,ann.pfamAnn, ann.tigrfam, ann.tigrfamAnn, ann.go)
  end
  print line.to_csv
end

line = [nil, nil]
allTot = 0
totcounts.keys.sort.each do |key|
  line.push(totcounts[key])
  allTot += totcounts[key]
end
line.push(allTot)
print line.to_csv