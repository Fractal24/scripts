#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'rubygems'
require 'fastercsv'
require 'Btab'
require 'dm-core'
require 'ZFile'
require 'bio'

opt = OpenStruct.new
o = OptionParser.new
opt.database = false
opt.verbose = false

o.banner << " fna btab [read.ali posmap]"
o.on("-d", "--database", "use database") {opt.database = true}
o.on("-v", "--verbose", "be verbose") {opt.verbose = true}
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size != 2 && ARGV.size != 4)
  STDERR << o
  exit(1)
end

fna, btab, ali, posmap = ARGV

lib = Hash.new

DataMapper.setup(:default, "mysql://access:access@mysql-lan-pro/phylodb")
db = repository(:default).adapter

annotation = Hash.new
matches = Hash.new
mapq =  "SELECT phylodb_seq_id, contigs.taxon_id, contigs.species, taxonomy, annotation,"
mapq += "gos_cluster_id, swiss, swiss.definition as swiss_def, cog_definitions.cog, " 
mapq += "cog_definitions.definition, phytax_cluster_id, map.ko, pathway, "
mapq += "map.pfam,pfam.definition as pfam_def, map.tigrfams, "
mapq += "tigrfams.definition as tigrfams_def FROM phylodb_annotation.map "
mapq += "LEFT JOIN phylodb_annotation.pathways USING(ko) "
mapq += "LEFT JOIN phylodb_annotation.pfam USING(pfam) " 
mapq += "LEFT JOIN phylodb_annotation.tigrfams USING(tigrfams) " 
mapq += "LEFT JOIN proteins ON phylodb_seq_id = proteins.name " 
mapq += "LEFT JOIN contigs ON contig_name = contigs.name "
mapq += "LEFT JOIN phylodb_annotation.blast ON blast.query = phylodb_seq_id "
mapq += "LEFT JOIN phylodb_annotation.swiss ON blast.hit = swiss "
mapq += "LEFT JOIN phylodb_annotation.cog_proteins ON blast.hit = protein "
mapq += "LEFT JOIN phylodb_annotation.cog_definitions ON cog_definitions.cog = cog_proteins.cog"
seen = Hash.new
pfam = Hash.new
tigrfam = Hash.new
STDERR << "Loading Btab...\n"
Btab.new(btab).each do |query|
  match = query.matches.first
  matches[query.name] = match.name
  annotation[match.name] = OpenStruct.new
  if (match.desc =~/(\S+)([^\{]*)\{([^\}]*)/)
    annotation[match.name].species = $3.strip
    annotation[match.name].annotation = $2.strip
  end
  seen["'#{match.name}'"] = true
end
if (opt.database)
  STDERR << "Fetching data from database...\n"
  list = seen.keys.reduce(:+)
  query = mapq + " WHERE phylodb_seq_id IN (#{seen.keys.join(",")})"
  db.select(query).each do |row|
    name = row.shift
    ann = annotation[name]
    ann.taxid, ann.species, ann.taxonomy, ann.annotation, ann.gos, swiss, swiss_ann, cog, cog_ann, ann.phytax, 
    ann.ko, ann.pathway, ann.pfam, ann.pfamAnn, ann.tigrfam, ann.tigrfamAnn = row
    ann.swiss, ann.swiss_ann = swiss, swiss_ann if (!swiss.nil?)
    ann.cog, ann.cog_ann = cog, cog_ann if (!cog.nil?)
    pfam["'#{ann.pfam}'"] = [] if (ann.pfam && !pfam["'#{ann.pfam}'"])
    tigrfam["'#{ann.tigrfam}'"] = [] if (ann.tigrfam && !pfam["'#{ann.tigrfam}'"])
  end
  db.select("SELECT pfam, go FROM pfam2go WHERE pfam IN (#{pfam.keys.join(",")})").each do |row|
    pfam["'#{row[0]}'"].push(row[1])
  end
  db.select("SELECT tigrfams, go FROM tigrfams2go WHERE tigrfams IN (#{tigrfam.keys.join(",")})").each do |row|
    tigrfam["'#{row[0]}'"].push(row[1])
  end
  db.select("SELECT jcvi, ncbi FROM ncbi WHERE jcvi IN (#{seen.keys.join(",")})").each do |row|
    jcvi, ncbi = row
    annotation[jcvi].ncbi = ncbi
  end
end


if (ali)
  STDERR << "Loading aliases...\n"
  ZFile.new(ali).each do |line|
    read, alname = line.chomp.split(" ")
    lib[read] = alname.split("_").first
  end
end

libcounts = Hash.new
totcounts = Hash.new

if (posmap)
  STDERR << "Loading posmap...\n"
  ZFile.new(posmap).each do |line|
    contig, read = line.chomp.split(" ")
    libcounts[contig] = Hash.new if libcounts[contig].nil?
    lread = lib[read]
    if (lread.nil?)
      STDERR << "No library for " << read << "\n" if (opt.verbose)
      next
    end
    libcounts[contig][lread] = 0 if libcounts[contig][lread].nil?
    libcounts[contig][lread] += 1
    totcounts[lread] = 0 if totcounts[lread].nil?
    totcounts[lread] += 1
  end
end

contigs = Hash.new
STDERR << "Loading DNA Info...\n"
Bio::FlatFile.new(Bio::FastaFormat, ZFile.new(fna)).each do |seq|
  seen[seq.entry_id] = true
  if (seq.definition =~/(isogroup[0-9]*)/)
    contigs[seq.entry_id] = $1
  else
    contigs[seq.entry_id] = ""  
  end
end

STDERR << "Writing Spreadsheet...\n"
header = ["Contigs", "Isogroup"]
totcounts.keys.sort.each do |key|
  header.push(key)
end
header.push("Sum")
totcounts.keys.sort.each do |key|
  header.push(key + " Normalized")
end
header.push("JCVI Match ID", "GenBank ID (if present)", "Annotation", "Species", "Taxon Id", "Taxonomy", 
"GOS Cluster", "Phytax Cluster", "Kegg Ortholog", "Kegg Pathway", "SwissProt", 
"SwissProt Ann", "COG", "COG Ann","PFAM","PFAM Ann", "TIGRFAM", 
"TIGRFAM Ann", "GO")
print header.to_csv

libcounts.keys.sort.each do |contig|
  line = [contig, contigs[contig]]
  sum = 0
  totcounts.keys.sort.each do |key|
    line.push(libcounts[contig][key].to_i)
    sum += libcounts[contig][key].to_i
  end
  line.push(sum)
  totcounts.keys.sort.each do |key|
    line.push(libcounts[contig][key].to_i/totcounts[key].to_f)
  end
  ann = annotation[matches[contig]]
  if (!ann.nil?)
    ann.go = (pfam["'#{ann.pfam}'"].to_a + tigrfam["'#{ann.tigrfam}'"].to_a).sort.uniq.join("; ")
    ann.annotation = "" if (ann.annotation.nil? || ann.annotation[0] == "{")
    line.push(matches[contig], ann.ncbi, ann.annotation, ann.species, ann.taxid, ann.taxonomy, 
      ann.gos, ann.phytax,ann.ko, ann.pathway, ann.swiss, ann.swiss_ann, ann.cog, ann.cog_ann, 
      ann.pfam,ann.pfamAnn, ann.tigrfam, ann.tigrfamAnn, ann.go)
  end
  print line.to_csv
end

line = [nil, nil]
allTot = 0
totcounts.keys.sort.each do |key|
  line.push(totcounts[key])
  allTot += totcounts[key]
end
line.push(allTot)
print line.to_csv