#!/usr/bin/env ruby

VER = "2.3"
DATE = "03/25/2013"

require 'rubygems'
begin
  require 'bio'
  require 'trollop'
  require 'Newick'
  require 'fpdf'
  require File.dirname($0)+"/apis_lib"
rescue LoadError # gems not installed
  miss = $!.to_s.gsub(">","").split(" ").last
  miss = "newick-ruby" if miss=="Newick"
  STDERR << "required gem \"" << miss << "\" is not installed\n"
  STDERR << "you can install it by typing:\n"
  STDERR << "gem install " << miss << "\n"
  STDERR << "Note that you may have to be root to do this\n"
  exit(1)
end

ARGV.push("--help") if ARGV.empty?

opts = Trollop::options do
	banner File.basename($0) << " " << VER << " " << DATE
	opt :blast, "NCBI Blast tab file with seguids", :required =>true, :type => :string
	opt :database, "Seguid-based fastacmd indexed protein database", :required => true, :type => :string
  opt :evalue, "maximum evalue for blast hit to be counted", :default=>1e-9, :type => :float
  opt :flatfile, "write flatfile to file specified summarizing results when done", :type => :string
  opt :exclude, "taxa to exclude in classification", :type => :strings
	opt :input, "DNA/Protein input fasta file to process", :required => true, :type => :string
  opt :maxhits, "Maximum blast hits per query sequence", :default=>50, :type => :integer
  opt :rulemaj, "Use majority rule rather than absolute consensus for classification", :default=>false
	opt :taxonomy, "APIS usedTaxa file", :required => true, :type => :string
  opt :trees, "create pdf-formatted versions of trees in specified directory", :type => :string
  opt :phylo, "Phylogenetic method", :default=>"nj", :type => :string
	opt :verbose, "print verbose status messages to STDERR"
end


# main loop

if (isDNA?(opts.input))
  input = asProt(input, opts.verbose)
else
  input = opts.input
end


taxonomy = loadTaxonomy(opts.taxonomy, opts.verbose)
blastF = FlatFileDB.new(opts.blast)

afas = File.new(File.basename(opts.input)+"_afa.txt", "w")
trees = File.new(File.basename(opts.input)+"_tree.txt", "w")
classes = File.new(File.basename(opts.input)+"_classification.txt", "w")
notrees = File.new(File.basename(opts.input)+"_notree.txt", "w")
Bio::FlatFile.new(Bio::FastaFormat, File.new(opts.input)).each do |pep|
  pid = pep.full_id
  blastids = getBlastHits(blastF, pep)
  if (blastids.size > 2) # 3 homologs + query is min tree
    afa = align(pep, blastids, opts.database, opts.verbose)
    afas.print pid + "\t" + afa + "\n"
    tree = infer(pid, afa, opts.phylo, opts.verbose)
    trees.print pid + "\t" + tree.to_s + "\n"
    if tree
      classy = classify(pid, tree, opts.rulemaj, opts.exclude, taxonomy, opts.verbose)
      classes.print pid + "\t" + classy + "\n"
    end
  else
    notrees.print pid + "\n"
  end
end
afas.close
trees.close
classes.close
notrees.close


# Bio::FlatFile(Bio::FastaFormat, File.new(input)).each do |pep|
#   #blastids = getBlastHits(blastF, pep)
#   #p blastids
#   next

#   end
# end
# exit(1)


# if (opts.flatfile)
#   STDERR << "Creating " << opts.flatfile << "...\n" if opts.verbose
#   out = File.new(opts.flatfile, "w")
#   trees.query("SELECT name, tree FROM trees ORDER BY name").each do |row|
#     name, tree = row
#     classy = classification.get_first_row("SELECT * FROM classification WHERE name=?", name)
#     out.print [classy + [tree]].join("\t") + "\n" if classy && tree
#   end
#   out.close
# end

# if (opts.trees)
#   STDERR << "Writing trees to " << opts.trees << "...\n" if opts.verbose
#   Dir.mkdir(opts.trees) if !File.exists?(opts.trees)
#   trees.query("SELECT name, tree FROM trees").each do |row|
#     name, tree = row
#     begin
#       NewickTree.new(tree).draw(opts.trees + "/" + name + ".pdf", boot="width", linker = :segLink)
#     rescue
#       STDERR << "Error #{$!} writing tree for #{name}...\n" if opts.verbose
#     end
#   end
# end