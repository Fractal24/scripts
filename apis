#!/usr/bin/env ruby

VER = "2.1a"
DATE = "01/17/2013"

require 'rubygems'
begin
  require 'trollop'
  require 'Newick'
  require 'bio'
  require 'fpdf'
  require 'sqlite3'
  require File.dirname($0)+"/apis_lib"
rescue LoadError # gems not installed
  miss = $!.to_s.gsub(">","").split(" ").last
  miss = "newick-ruby" if miss=="Newick"
  STDERR << "required gem \"" << miss << "\" is not installed\n"
  STDERR << "you can install it by typing:\n"
  STDERR << "gem install " << miss << "\n"
  STDERR << "Note that you may have to be root to do this\n"
  exit(1)
end

ARGV.push("--help") if ARGV.empty?

opts = Trollop::options do
	banner File.basename($0) << " " << VER << " " << DATE
	opt :blast, "NCBI Blast tab file(s) with seguids", :required =>true, :type => :strings
	opt :database, "Seguid-based fastacmd indexed protein database", :required => true, :type => :string
  opt :evalue, "maximum evalue for blast hit to be counted", :default=>1e-9, :type => :float
  opt :flatfile, "write flatfile to file specified summarizing results when done", :type => :string
  opt :exclude, "taxa to exclude in classification", :type => :strings
	opt :input, "DNA/Protein input fasta file to process", :required => true, :type => :string
  opt :maxhits, "Maximum blast hits per query sequence", :default=>50, :type => :integer
  opt :rulemaj, "Use majority rule rather than absolute consensus for classification", :default=>false
	opt :taxonomy, "APIS usedTaxa file", :required => true, :type => :string
  opt :trees, "create pdf-formatted versions of trees in specified directory", :type => :string
  opt :phylo, "Phylogenetic method", :default=>"nj", :type => :string
	opt :verbose, "print verbose status messages to STDERR"
end

# main loop

opts.input = asProt(opts.input, opts.verbose) if isDNA?(opts.input)

taxonomy = loadTaxonomy(opts.taxonomy, opts.verbose)
peps = loadPeps(opts.input, opts.verbose)
blast = loadBlast(opts.input, opts.blast, opts.evalue, opts.maxhits, opts.verbose)
alignment = createAlignmentDB(opts.input)
trees = createTreesDB(opts.input)
classification = createClassificationDB(opts.input)

unprocessed = Hash.new
peps.query("SELECT name FROM peptides WHERE processed = 0").each do |row|
  unprocessed[row.first] = true
end

unprocessed.keys.sort.each do |pep|
  blastids = blast.query("SELECT hit FROM blast WHERE name=?", pep).entries.flatten
  if (blastids.size > 2) # 3 homologs + query is min tree
    afa = align(alignment, pep, peps, blastids, opts.database, opts.verbose)
    tree = infer(trees, afa, pep, opts.phylo, opts.verbose)
    classify(classification, pep, tree, opts.rulemaj, opts.exclude, taxonomy, opts.verbose) if tree
  end
  peps.execute("UPDATE peptides SET processed = 1 WHERE name = ?", pep)
end

if (opts.flatfile)
  STDERR << "Creating " << opts.flatfile << "...\n" if opts.verbose
  out = File.new(opts.flatfile, "w")
  trees.query("SELECT name, tree FROM trees ORDER BY name").each do |row|
    name, tree = row
    classy = classification.get_first_row("SELECT * FROM classification WHERE name=?", name)
    out.print [classy + [tree]].join("\t") + "\n" if classy && tree
  end
  out.close
end

if (opts.trees)
  STDERR << "Writing trees to " << opts.trees << "...\n" if opts.verbose
  Dir.mkdir(opts.trees) if !File.exists?(opts.trees)
  trees.query("SELECT name, tree FROM trees").each do |row|
    name, tree = row
    begin
      NewickTree.new(tree).draw(opts.trees + "/" + name + ".pdf", boot="width", linker = :segLink)
    rescue
      STDERR << "Error #{$!} writing tree for #{name}...\n" if opts.verbose
    end
  end
end


